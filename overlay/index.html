<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE FINALS Loadout - OBS Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            color: #fff;
            overflow: hidden;
            position: relative;
            width: 600px;
            height: 180px;
            margin: 0;
            padding: 0;
        }

        /* Slot Machine Style Container */
        .overlay-container {
            position: absolute;
            background: linear-gradient(135deg, rgba(20, 10, 25, 0.98) 0%, rgba(35, 20, 40, 0.95) 100%);
            border-radius: 8px;
            border: 1px solid rgba(255, 71, 150, 0.4);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.9);
            transition: all 0.3s ease;
            width: 540px;
            height: 160px;
            padding: 8px 8px 12px 8px;
            top: 5px;
            left: 10px;
        }

        /* Position presets */
        .top-left { top: 10px; left: 10px; }
        .top-right { top: 10px; right: 10px; }
        .bottom-left { bottom: 10px; left: 10px; }
        .bottom-right { bottom: 10px; right: 10px; }
        .center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Theme presets */
        .theme-dark {
            background: linear-gradient(135deg, rgba(20, 10, 25, 0.98) 0%, rgba(35, 20, 40, 0.95) 100%);
            border-color: rgba(255, 71, 150, 0.4);
        }

        .theme-light {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(240, 240, 240, 0.9) 100%);
            color: #000;
            border-color: rgba(0, 0, 0, 0.2);
        }

        .theme-light .column-header {
            color: #ff4796 !important;
        }

        .theme-finals {
            background: linear-gradient(135deg, rgba(228, 49, 79, 0.95) 0%, rgba(200, 30, 60, 0.9) 100%);
            border-color: rgba(228, 49, 79, 0.5);
        }

        .theme-finals .column-header {
            color: #ffffff !important;
        }

        .theme-finals .site-branding {
            background: none;
            -webkit-text-fill-color: #ffffff;
        }

        .theme-finals .class-name {
            color: #ffffff !important;
        }

        .theme-finals .item-name {
            color: #ffffff !important;
        }

        .theme-transparent {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 71, 150, 0.4);
            backdrop-filter: blur(10px);
        }

        /* Class Header */
        .class-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: linear-gradient(90deg, rgba(255, 71, 150, 0.15) 0%, rgba(150, 71, 255, 0.1) 100%);
            border-radius: 5px;
        }

        .class-name {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .site-branding {
            font-size: 16px;
            background: linear-gradient(90deg, #ff4796, #ff71b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .class-light { color: #ff4796; }
        .class-medium { color: #9b59b6; }
        .class-heavy { color: #3498db; }

        /* Slot Machine Columns */
        .slot-columns {
            display: flex;
            gap: 0;
            justify-content: center;
            padding: 0;
        }

        .slot-column {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 71, 150, 0.2);
            border-right: none;
            padding: 6px;
            min-width: 100px;
            flex: 1;
            transition: transform 0.3s ease;
        }

        .slot-column:first-child {
            border-radius: 6px 0 0 6px;
        }

        .slot-column:last-child {
            border-radius: 0 6px 6px 0;
            border-right: 1px solid rgba(255, 71, 150, 0.2);
        }

        .slot-column:hover {
            transform: translateY(-2px);
            border-color: rgba(255, 71, 150, 0.4);
        }

        .column-header {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            margin-bottom: 6px;
            color: #ff71b0;
            font-weight: bold;
        }

        .item-display {
            background: rgba(255, 71, 150, 0.06);
            border: 1px solid rgba(255, 71, 150, 0.15);
            border-radius: 4px;
            padding: 4px;
            text-align: center;
            height: 72px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .item-image {
            width: 48px;
            height: 48px;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.7));
            transition: transform 0.2s ease;
        }

        .item-image:hover {
            transform: scale(1.1);
        }

        .item-name {
            font-size: 9px;
            font-weight: 500;
            line-height: 1.1;
            word-wrap: break-word;
            max-width: 100%;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 2px;
        }

        /* Animations */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 71, 150, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 71, 150, 0.8); }
        }

        .animate-in {
            animation: slideIn 0.5s ease;
        }

        .new-loadout .item-display {
            animation: glow 1s ease-in-out;
        }

        /* Compact mode */
        .compact {
            width: 540px;
            height: 160px;
            padding: 8px 8px 12px 8px;
        }

        .compact .class-header {
            padding: 4px 8px;
            margin-bottom: 4px;
        }

        .compact .class-name {
            font-size: 14px;
        }

        .compact .site-branding {
            font-size: 14px;
        }

        .compact .slot-columns {
            padding: 0;
            gap: 0;
        }

        .compact .slot-column {
            min-width: 85px;
            padding: 6px;
        }

        .compact .column-header {
            font-size: 8px;
            margin-bottom: 4px;
        }

        .compact .item-display {
            padding: 4px;
            height: 65px;
            gap: 2px;
        }

        .compact .item-image {
            width: 40px;
            height: 40px;
        }

        .compact .item-name {
            font-size: 9px;
        }

        /* Hidden state */
        .hidden {
            display: none;
        }

        /* No loadout state */
        .no-loadout {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Loading dots animation */
        .loading-dots {
            display: inline-block;
        }

        .loading-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Fallback for missing images */
        .item-icon-fallback {
            width: 60px;
            height: 60px;
            background: rgba(255, 107, 53, 0.2);
            border: 2px solid rgba(255, 107, 53, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ff6b35;
        }

        .compact .item-icon-fallback {
            width: 45px;
            height: 45px;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="overlayContainer" class="overlay-container theme-dark">
        <div class="no-loadout">
            <div class="class-header">
                <div style="font-size: 16px; font-weight: bold; background: linear-gradient(90deg, #ff4796, #ff71b0); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">WAITING</div>
                <div class="site-branding">TheFinalsLoadout.com</div>
            </div>
            <div style="padding: 20px; text-align: center;">
                <p style="margin: 0; color: rgba(255, 255, 255, 0.7); font-size: 12px;">Generate a loadout to display here<span class="loading-dots"></span></p>
            </div>
        </div>
    </div>

    <script>
        // Configuration from URL parameters
        const params = new URLSearchParams(window.location.search);
        const config = {
            position: params.get('position') || 'top-right',
            theme: params.get('theme') || 'dark',
            compact: params.get('compact') === 'true',
            hideEmpty: params.get('hideEmpty') === 'true',
            channel: params.get('channel') || 'default',
            refresh: parseInt(params.get('refresh')) || 500,
            animate: params.get('animate') !== 'false'
        };

        // Apply configuration
        const container = document.getElementById('overlayContainer');
        container.className = `overlay-container ${config.position} theme-${config.theme}${config.compact ? ' compact' : ''}`;

        // Icon fallbacks for different item types
        const itemIcons = {
            weapon: '🔫',
            specialization: '⚡',
            gadget: '🎯'
        };

        // Function to create item HTML with image or fallback
        function createItemHTML(item, type, index) {
            const name = typeof item === 'object' ? item.name : item;
            const image = typeof item === 'object' ? item.image : null;

            let imageHTML;
            console.log(`Item: ${name}, Image path: ${image}`); // Debug log

            if (image && image !== 'null' && image !== null) {
                // Fix relative paths for images
                let imageSrc = image;
                if (image.startsWith('../images/')) {
                    // Convert relative path from stream-tools context to overlay context
                    imageSrc = image.replace('../images/', '/images/');
                }
                // Try to load the image with debugging
                imageHTML = `<img class="item-image" src="${imageSrc}" alt="${name}"
                            onload="console.log('✅ Loaded: ${name}')"
                            onerror="console.error('❌ Failed to load: ${name} from ${imageSrc}'); this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="item-icon-fallback" style="display:none;">${itemIcons[type] || '📦'}</div>`;
            } else {
                // Use fallback icon
                console.log(`No image for ${name}, using fallback icon`);
                imageHTML = `<div class="item-icon-fallback">${itemIcons[type] || '📦'}</div>`;
            }

            const headerText = type === 'gadget' ? `GADGET ${index + 1}` : type.toUpperCase();

            return `
                <div class="slot-column">
                    <div class="column-header">${headerText}</div>
                    <div class="item-display">
                        ${imageHTML}
                        <div class="item-name">${name || 'Empty'}</div>
                    </div>
                </div>
            `;
        }

        // Function to render loadout in slot machine style
        function renderLoadout(loadout) {
            console.log('🎰 Rendering loadout:', loadout); // Debug the entire loadout

            if (!loadout || !loadout.class) {
                console.log('❌ Invalid loadout - missing class');
                if (config.hideEmpty) {
                    container.classList.add('hidden');
                } else {
                    container.classList.remove('hidden');
                    container.innerHTML = `
                        <div class="no-loadout">
                            <h3>Waiting for Loadout<span class="loading-dots"></span></h3>
                            <p>Generate a loadout on THE FINALS Loadout website!</p>
                        </div>
                    `;
                }
                return;
            }

            // Normalize loadout format (handle both old and new formats)
            const normalizedLoadout = {
                class: loadout.class,
                name: loadout.name || 'Generated Loadout',
                weapon: typeof loadout.weapon === 'string'
                    ? { name: loadout.weapon, image: `/images/${loadout.weapon.replace(/ /g, '_')}.webp` }
                    : loadout.weapon,
                specialization: typeof loadout.specialization === 'string'
                    ? { name: loadout.specialization, image: `/images/${loadout.specialization.replace(/ /g, '_')}.webp` }
                    : loadout.specialization,
                gadgets: []
            };

            // Handle gadgets in various formats
            if (loadout.gadgets && Array.isArray(loadout.gadgets)) {
                normalizedLoadout.gadgets = loadout.gadgets.map(g =>
                    typeof g === 'string' ? { name: g, image: `/images/${g.replace(/ /g, '_')}.webp` } : g
                );
            } else if (loadout.gadget1 || loadout.gadget2 || loadout.gadget3) {
                // Handle old format with gadget1, gadget2, gadget3
                if (loadout.gadget1) normalizedLoadout.gadgets.push({ name: loadout.gadget1, image: `/images/${loadout.gadget1.replace(/ /g, '_')}.webp` });
                if (loadout.gadget2) normalizedLoadout.gadgets.push({ name: loadout.gadget2, image: `/images/${loadout.gadget2.replace(/ /g, '_')}.webp` });
                if (loadout.gadget3) normalizedLoadout.gadgets.push({ name: loadout.gadget3, image: `/images/${loadout.gadget3.replace(/ /g, '_')}.webp` });
            }

            console.log('📦 Normalized loadout:', normalizedLoadout);
            loadout = normalizedLoadout;

            container.classList.remove('hidden');

            const classLower = (loadout.class || 'unknown').toLowerCase();

            // Build columns HTML
            let columnsHTML = '';

            // Weapon column
            columnsHTML += createItemHTML(loadout.weapon, 'weapon', 0);

            // Specialization column
            columnsHTML += createItemHTML(loadout.specialization, 'specialization', 0);

            // Gadgets columns
            if (loadout.gadgets && loadout.gadgets.length > 0) {
                loadout.gadgets.forEach((gadget, index) => {
                    columnsHTML += createItemHTML(gadget, 'gadget', index);
                });
            } else {
                columnsHTML += createItemHTML('None', 'gadget', 0);
            }

            const loadoutHTML = `
                <div class="class-header">
                    <div class="class-name class-${classLower}">${loadout.class} BUILD</div>
                    <div class="site-branding">TheFinalsLoadout.com</div>
                </div>
                <div class="slot-columns">
                    ${columnsHTML}
                </div>
            `;

            container.innerHTML = loadoutHTML;

            if (config.animate) {
                container.classList.add('animate-in', 'new-loadout');
                setTimeout(() => {
                    container.classList.remove('animate-in', 'new-loadout');
                }, 1000);
            }
        }

        // Try BroadcastChannel for cross-context communication
        let broadcastChannel = null;
        try {
            broadcastChannel = new BroadcastChannel('loadout_overlay_channel');
            broadcastChannel.onmessage = (event) => {
                console.log('Received broadcast:', event.data);
                if (event.data && event.data.type === 'loadout_update') {
                    renderLoadout(event.data.loadout);
                }
            };
            console.log('BroadcastChannel initialized');
        } catch (e) {
            console.log('BroadcastChannel not supported, falling back to localStorage polling');
        }

        // Function to check for loadout updates
        let lastLoadout = null;
        let updateCount = 0;
        function checkForUpdates() {
            try {
                // Check localStorage for current loadout
                const storageKey = `loadout_overlay_${config.channel}`;
                const storedLoadout = localStorage.getItem(storageKey);

                // Log every 10th check to avoid spam
                if (updateCount++ % 10 === 0) {
                    console.log(`Checking localStorage key: ${storageKey}, found:`, storedLoadout ? 'yes' : 'no');
                }

                if (storedLoadout) {
                    const loadout = JSON.parse(storedLoadout);
                    // Only update if loadout changed
                    if (JSON.stringify(loadout) !== JSON.stringify(lastLoadout)) {
                        console.log('📦 New loadout detected in localStorage!');
                        lastLoadout = loadout;
                        renderLoadout(loadout);
                    }
                }

                // Also check for loadout in URL (for direct linking)
                const urlLoadout = params.get('loadout');
                if (urlLoadout) {
                    try {
                        const loadout = JSON.parse(decodeURIComponent(urlLoadout));
                        if (JSON.stringify(loadout) !== JSON.stringify(lastLoadout)) {
                            lastLoadout = loadout;
                            renderLoadout(loadout);
                        }
                    } catch (e) {
                        console.error('Failed to parse URL loadout:', e);
                    }
                }

                // Check for simple URL parameters (for OBS)
                const urlClass = params.get('class');
                const urlWeapon = params.get('weapon');
                if (urlClass && urlWeapon && !lastLoadout) {
                    const simpleLoadout = {
                        class: urlClass,
                        weapon: { name: decodeURIComponent(urlWeapon) },
                        specialization: { name: decodeURIComponent(params.get('spec') || 'None') },
                        gadgets: []
                    };
                    if (params.get('g1')) simpleLoadout.gadgets.push({ name: decodeURIComponent(params.get('g1')) });
                    if (params.get('g2')) simpleLoadout.gadgets.push({ name: decodeURIComponent(params.get('g2')) });
                    if (params.get('g3')) simpleLoadout.gadgets.push({ name: decodeURIComponent(params.get('g3')) });
                    console.log('📦 Built loadout from URL params:', simpleLoadout);
                    renderLoadout(simpleLoadout);
                }
            } catch (e) {
                console.error('Error checking for updates:', e);
            }
        }

        // Listen for storage events (updates from main site)
        window.addEventListener('storage', (e) => {
            if (e.key === `loadout_overlay_${config.channel}`) {
                checkForUpdates();
            }
        });

        // Initial check - with delay to ensure everything is loaded
        setTimeout(() => {
            console.log('🔍 Running initial check for existing loadout');
            checkForUpdates();

            // Also check a default key for OBS compatibility
            const defaultLoadout = localStorage.getItem('loadout_overlay_default');
            if (defaultLoadout && !lastLoadout) {
                console.log('📦 Found default loadout for OBS');
                try {
                    const loadout = JSON.parse(defaultLoadout);
                    renderLoadout(loadout);
                } catch (e) {
                    console.error('Failed to parse default loadout:', e);
                }
            }

            // Fallback: Check ALL localStorage keys for any loadout
            if (!lastLoadout) {
                console.log('🔍 Checking all localStorage for any loadout...');
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.includes('loadout_overlay_')) {
                        console.log(`Found key: ${key}`);
                        try {
                            const data = localStorage.getItem(key);
                            const loadout = JSON.parse(data);
                            if (loadout && loadout.class) {
                                console.log(`✅ Using loadout from ${key}`);
                                renderLoadout(loadout);
                                break;
                            }
                        } catch (e) {
                            console.log(`Failed to parse ${key}:`, e);
                        }
                    }
                }
            }
        }, 500);

        // Regular polling as backup - more frequent for better responsiveness
        setInterval(checkForUpdates, 250); // Check every 250ms instead of 500ms

        // Listen for postMessage from parent window (for iframe preview)
        window.addEventListener('message', (event) => {
            console.log('📨 Overlay received postMessage from:', event.origin);
            console.log('Message data:', event.data);

            // Handle ping messages for testing
            if (event.data && event.data.type === 'ping') {
                console.log('🏓 Received ping:', event.data.message);
                // Send pong back
                if (event.source) {
                    event.source.postMessage({ type: 'pong', message: 'Overlay ready' }, event.origin);
                }
            }

            // Accept messages from any origin in production (be careful with this in real production)
            if (event.data && event.data.type === 'loadout_update' && event.data.payload) {
                console.log('✅ Processing loadout from postMessage');
                renderLoadout(event.data.payload);
            }
        });

        // Get channel from URL first
        const params = new URLSearchParams(window.location.search);
        const channelId = params.get('channel') || 'default';

        // Log initial state with more detail
        console.log('🎮 Stream overlay initialized at', new Date().toISOString());
        console.log('Channel ID:', channelId);
        console.log('Config:', config);
        console.log('Window location:', window.location.href);
        console.log('Parent location:', window.parent !== window ? 'Has parent frame' : 'No parent frame');
        console.log('LocalStorage available:', typeof(Storage) !== "undefined");

        // Check for existing data on load
        const existingData = localStorage.getItem(`loadout_overlay_${channelId}`);
        const defaultData = localStorage.getItem('loadout_overlay_default');
        console.log('Existing channel data:', existingData ? 'Found' : 'Not found');
        console.log('Default data:', defaultData ? 'Found' : 'Not found');

        // Add a visible indicator that script is running
        if (window.location.search.includes('debug=true')) {
            const debugDiv = document.createElement('div');
            debugDiv.style.cssText = 'position: fixed; top: 0; right: 0; background: lime; color: black; padding: 5px; z-index: 9999;';
            debugDiv.textContent = 'Overlay Script Running';
            document.body.appendChild(debugDiv);
        }

        // Direct method for parent window to send loadout
        window.receiveLoadout = function(loadout) {
            console.log('📦 Received loadout via direct call:', loadout);
            renderLoadout(loadout);
        };

        // Test function for development
        window.testLoadout = function() {
            const classes = ['Light', 'Medium', 'Heavy'];
            const weapons = {
                Light: ['V9S', 'XP-54', 'M11', 'LH1', 'Dagger', 'Sword', 'Throwing Knives'],
                Medium: ['FCAR', 'AKM', 'R.357', 'Model 1887', 'FAMAS'],
                Heavy: ['SA1216', 'M60', 'Lewis Gun', 'Flamethrower', 'Sledgehammer']
            };
            const specializations = {
                Light: ['Evasive Dash', 'Grappling Hook', 'Cloaking Device'],
                Medium: ['Guardian Turret', 'Healing Beam', 'Dematerializer'],
                Heavy: ['Mesh Shield', 'Charge \'n\' Slam', 'Goo Gun']
            };
            const gadgets = ['Frag Grenade', 'Gas Grenade', 'Goo Grenade', 'Flashbang', 'Smoke Grenade', 'C4', 'RPG', 'Defibrillator'];

            const selectedClass = classes[Math.floor(Math.random() * classes.length)];
            const classWeapons = weapons[selectedClass];
            const classSpecs = specializations[selectedClass];

            const testData = {
                class: selectedClass,
                name: 'Test Loadout',
                weapon: {
                    name: classWeapons[Math.floor(Math.random() * classWeapons.length)],
                    image: '/images/weapons/fcar.png'  // Example image path
                },
                specialization: {
                    name: classSpecs[Math.floor(Math.random() * classSpecs.length)],
                    image: '/images/specializations/healing-beam.png'  // Example image path
                },
                gadgets: [
                    { name: gadgets[Math.floor(Math.random() * gadgets.length)], image: '/images/gadgets/frag.png' },
                    { name: gadgets[Math.floor(Math.random() * gadgets.length)], image: null },
                    { name: gadgets[Math.floor(Math.random() * gadgets.length)], image: null }
                ],
                timestamp: new Date().toISOString()
            };
            localStorage.setItem(`loadout_overlay_${config.channel}`, JSON.stringify(testData));
        };
    </script>

    <!-- Supabase Integration (Optional - will fallback to localStorage if not available) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase if available
        let supabaseOverlay = null;
        let channelOverlay = null;

        if (typeof window.supabase !== 'undefined') {
            try {
                // Initialize Supabase - MUST match the stream-tools page credentials
                const SUPABASE_URL = 'https://nabbbidjnmljaadmjjln.supabase.co';
                const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5hYmJiaWRqbm1samFhZG1qamxuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzcxNTI2MDAsImV4cCI6MjA1MjcyODYwMH0.C-apFqin1kBOOV8L3R8Y0cakcAU2A8KtFqQr2PwVHAc';
                supabaseOverlay = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
                    realtime: {
                        params: {
                            log_level: 'info'
                        }
                    }
                });
                console.log('Supabase client created successfully');
            } catch (e) {
                console.log('Failed to initialize Supabase:', e);
            }
        } else {
            console.log('Supabase library not loaded, using localStorage/BroadcastChannel fallback');
        }

        // Use the channel ID we already got above
        const channelName = channelId; // Use the channel ID directly, not 'overlay_' prefix

        // Only try Supabase if it was successfully initialized
        if (supabaseOverlay) {
            try {
                // ALWAYS listen to obs_default channel for OBS
                const obsChannel = supabaseOverlay.channel('obs_default');

                obsChannel
                    .on('broadcast', { event: 'loadout_update' }, (payload) => {
                        console.log(`✅ Received loadout from OBS channel`, payload);
                        renderLoadout(payload.payload);
                    })
                    .subscribe((status, error) => {
                        if (error) {
                            console.error('❌ Channel subscription error:', error);
                            console.log('Channel error details:', error.message);
                        } else if (status === 'SUBSCRIBED') {
                            console.log(`✅ Connected to OBS channel: obs_default! Waiting for loadouts...`);
                        } else if (status === 'CHANNEL_ERROR') {
                            console.error('❌ Channel error - check Supabase configuration');
                        } else if (status === 'TIMED_OUT') {
                            console.error('❌ Connection timed out - retrying...');
                        } else {
                            console.log(`Channel status: ${status}`);
                        }
                    });

                // Also listen on user's specific channel if provided
                if (channelId && channelId !== 'default') {
                    const userChannel = supabaseOverlay.channel(channelName);
                    userChannel
                        .on('broadcast', { event: 'loadout_update' }, (payload) => {
                            console.log(`✅ Received loadout from user channel: ${channelName}`, payload);
                            renderLoadout(payload.payload);
                        })
                        .subscribe((status) => {
                            if (status === 'SUBSCRIBED') {
                                console.log(`✅ Also connected to user channel: ${channelName}`);
                            }
                        });
                }
            } catch (e) {
                console.log('Supabase connection failed, falling back to localStorage/BroadcastChannel', e);
            }
        }
    </script>
</body>
</html>