<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE FINALS Loadout - OBS Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            color: #fff;
            overflow: hidden;
            position: relative;
            width: 600px;
            height: 180px;
            margin: 0;
            padding: 0;
        }

        /* Slot Machine Style Container */
        .overlay-container {
            position: absolute;
            background: linear-gradient(135deg, rgba(20, 10, 25, 0.98) 0%, rgba(35, 20, 40, 0.95) 100%);
            border-radius: 8px;
            border: 1px solid rgba(255, 71, 150, 0.4);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.9);
            transition: all 0.3s ease;
            width: 540px;
            height: 160px;
            padding: 8px 8px 12px 8px;
            top: 5px;
            left: 10px;
        }

        /* Position presets */
        .top-left { top: 10px; left: 10px; }
        .top-right { top: 10px; right: 10px; }
        .bottom-left { bottom: 10px; left: 10px; }
        .bottom-right { bottom: 10px; right: 10px; }
        .center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Theme presets */
        .theme-dark {
            background: linear-gradient(135deg, rgba(20, 10, 25, 0.98) 0%, rgba(35, 20, 40, 0.95) 100%);
            border-color: rgba(255, 71, 150, 0.4);
        }

        .theme-light {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(240, 240, 240, 0.9) 100%);
            color: #000;
            border-color: rgba(0, 0, 0, 0.2);
        }

        .theme-light .column-header {
            color: #ff4796 !important;
        }

        .theme-finals {
            background: linear-gradient(135deg, rgba(228, 49, 79, 0.95) 0%, rgba(200, 30, 60, 0.9) 100%);
            border-color: rgba(228, 49, 79, 0.5);
        }

        .theme-finals .column-header {
            color: #ffffff !important;
        }

        .theme-finals .site-branding {
            background: none;
            -webkit-text-fill-color: #ffffff;
        }

        .theme-finals .class-name {
            color: #ffffff !important;
        }

        .theme-finals .item-name {
            color: #ffffff !important;
        }

        .theme-transparent {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 71, 150, 0.4);
            backdrop-filter: blur(10px);
        }

        /* Class Header */
        .class-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: linear-gradient(90deg, rgba(255, 71, 150, 0.15) 0%, rgba(150, 71, 255, 0.1) 100%);
            border-radius: 5px;
        }

        .class-name {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .site-branding {
            font-size: 16px;
            background: linear-gradient(90deg, #ff4796, #ff71b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .class-light { color: #ff4796; }
        .class-medium { color: #9b59b6; }
        .class-heavy { color: #3498db; }

        /* Slot Machine Columns */
        .slot-columns {
            display: flex;
            gap: 0;
            justify-content: center;
            padding: 0;
        }

        .slot-column {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 71, 150, 0.2);
            border-right: none;
            padding: 6px;
            min-width: 100px;
            flex: 1;
            transition: transform 0.3s ease;
        }

        .slot-column:first-child {
            border-radius: 6px 0 0 6px;
        }

        .slot-column:last-child {
            border-radius: 0 6px 6px 0;
            border-right: 1px solid rgba(255, 71, 150, 0.2);
        }

        .slot-column:hover {
            transform: translateY(-2px);
            border-color: rgba(255, 71, 150, 0.4);
        }

        .column-header {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            margin-bottom: 6px;
            color: #ff71b0;
            font-weight: bold;
        }

        .item-display {
            background: rgba(255, 71, 150, 0.06);
            border: 1px solid rgba(255, 71, 150, 0.15);
            border-radius: 4px;
            padding: 4px;
            text-align: center;
            height: 72px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .item-image {
            width: 48px;
            height: 48px;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.7));
            transition: transform 0.2s ease;
        }

        .item-image:hover {
            transform: scale(1.1);
        }

        .item-name {
            font-size: 9px;
            font-weight: 500;
            line-height: 1.1;
            word-wrap: break-word;
            max-width: 100%;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 2px;
        }

        /* Animations */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 71, 150, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 71, 150, 0.8); }
        }

        .animate-in {
            animation: slideIn 0.5s ease;
        }

        .new-loadout .item-display {
            animation: glow 1s ease-in-out;
        }

        /* Compact mode */
        .compact {
            width: 540px;
            height: 160px;
            padding: 8px 8px 12px 8px;
        }

        .compact .class-header {
            padding: 4px 8px;
            margin-bottom: 4px;
        }

        .compact .class-name {
            font-size: 14px;
        }

        .compact .site-branding {
            font-size: 14px;
        }

        .compact .slot-columns {
            padding: 0;
            gap: 0;
        }

        .compact .slot-column {
            min-width: 85px;
            padding: 6px;
        }

        .compact .column-header {
            font-size: 8px;
            margin-bottom: 4px;
        }

        .compact .item-display {
            padding: 4px;
            height: 65px;
            gap: 2px;
        }

        .compact .item-image {
            width: 40px;
            height: 40px;
        }

        .compact .item-name {
            font-size: 9px;
        }

        /* Hidden state */
        .hidden {
            display: none;
        }

        /* No loadout state */
        .no-loadout {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Loading dots animation */
        .loading-dots {
            display: inline-block;
        }

        .loading-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Fallback for missing images */
        .item-icon-fallback {
            width: 60px;
            height: 60px;
            background: rgba(255, 107, 53, 0.2);
            border: 2px solid rgba(255, 107, 53, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ff6b35;
        }

        .compact .item-icon-fallback {
            width: 45px;
            height: 45px;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="overlayContainer" class="overlay-container theme-dark">
        <div class="no-loadout">
            <div class="class-header">
                <div style="font-size: 16px; font-weight: bold; background: linear-gradient(90deg, #ff4796, #ff71b0); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">WAITING</div>
                <div class="site-branding">TheFinalsLoadout.com</div>
            </div>
            <div style="padding: 20px; text-align: center;">
                <p style="margin: 0; color: rgba(255, 255, 255, 0.7); font-size: 12px;">Generate a loadout to display here<span class="loading-dots"></span></p>
            </div>
        </div>
    </div>

    <script>
        // Configuration from URL parameters
        const params = new URLSearchParams(window.location.search);
        const config = {
            position: params.get('position') || 'top-right',
            theme: params.get('theme') || 'dark',
            compact: params.get('compact') === 'true',
            hideEmpty: params.get('hideEmpty') === 'true',
            channel: params.get('channel') || 'default',
            refresh: parseInt(params.get('refresh')) || 500,
            animate: params.get('animate') !== 'false'
        };

        // Apply configuration
        const container = document.getElementById('overlayContainer');
        container.className = `overlay-container ${config.position} theme-${config.theme}${config.compact ? ' compact' : ''}`;

        // Icon fallbacks for different item types
        const itemIcons = {
            weapon: '🔫',
            specialization: '⚡',
            gadget: '🎯'
        };

        // Function to create item HTML with image or fallback
        function createItemHTML(item, type, index) {
            const name = typeof item === 'object' ? item.name : item;
            const image = typeof item === 'object' ? item.image : null;

            let imageHTML;
            console.log(`Item: ${name}, Image path: ${image}`); // Debug log

            if (image && image !== 'null' && image !== null) {
                // Fix relative paths for images
                let imageSrc = image;
                if (image.startsWith('../images/')) {
                    // Convert relative path from stream-tools context to overlay context
                    imageSrc = image.replace('../images/', '/images/');
                }
                // Try to load the image with debugging
                imageHTML = `<img class="item-image" src="${imageSrc}" alt="${name}"
                            onload="console.log('✅ Loaded: ${name}')"
                            onerror="console.error('❌ Failed to load: ${name} from ${imageSrc}'); this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="item-icon-fallback" style="display:none;">${itemIcons[type] || '📦'}</div>`;
            } else {
                // Use fallback icon
                console.log(`No image for ${name}, using fallback icon`);
                imageHTML = `<div class="item-icon-fallback">${itemIcons[type] || '📦'}</div>`;
            }

            const headerText = type === 'gadget' ? `GADGET ${index + 1}` : type.toUpperCase();

            return `
                <div class="slot-column">
                    <div class="column-header">${headerText}</div>
                    <div class="item-display">
                        ${imageHTML}
                        <div class="item-name">${name || 'Empty'}</div>
                    </div>
                </div>
            `;
        }

        // Function to render loadout in slot machine style
        function renderLoadout(loadout) {
            console.log('🎰 Rendering loadout:', loadout); // Debug the entire loadout

            if (!loadout || !loadout.class) {
                if (config.hideEmpty) {
                    container.classList.add('hidden');
                } else {
                    container.classList.remove('hidden');
                    container.innerHTML = `
                        <div class="no-loadout">
                            <h3>Waiting for Loadout<span class="loading-dots"></span></h3>
                            <p>Generate a loadout on THE FINALS Loadout website!</p>
                        </div>
                    `;
                }
                return;
            }

            container.classList.remove('hidden');

            const classLower = (loadout.class || 'unknown').toLowerCase();

            // Build columns HTML
            let columnsHTML = '';

            // Weapon column
            columnsHTML += createItemHTML(loadout.weapon, 'weapon', 0);

            // Specialization column
            columnsHTML += createItemHTML(loadout.specialization, 'specialization', 0);

            // Gadgets columns
            if (loadout.gadgets && loadout.gadgets.length > 0) {
                loadout.gadgets.forEach((gadget, index) => {
                    columnsHTML += createItemHTML(gadget, 'gadget', index);
                });
            } else {
                columnsHTML += createItemHTML('None', 'gadget', 0);
            }

            const loadoutHTML = `
                <div class="class-header">
                    <div class="class-name class-${classLower}">${loadout.class} BUILD</div>
                    <div class="site-branding">TheFinalsLoadout.com</div>
                </div>
                <div class="slot-columns">
                    ${columnsHTML}
                </div>
            `;

            container.innerHTML = loadoutHTML;

            if (config.animate) {
                container.classList.add('animate-in', 'new-loadout');
                setTimeout(() => {
                    container.classList.remove('animate-in', 'new-loadout');
                }, 1000);
            }
        }

        // Try BroadcastChannel for cross-context communication
        let broadcastChannel = null;
        try {
            broadcastChannel = new BroadcastChannel('loadout_overlay_channel');
            broadcastChannel.onmessage = (event) => {
                console.log('Received broadcast:', event.data);
                if (event.data && event.data.type === 'loadout_update') {
                    renderLoadout(event.data.loadout);
                }
            };
            console.log('BroadcastChannel initialized');
        } catch (e) {
            console.log('BroadcastChannel not supported, falling back to localStorage polling');
        }

        // Function to check for loadout updates
        let lastLoadout = null;
        let updateCount = 0;
        function checkForUpdates() {
            try {
                // Check localStorage for current loadout
                const storageKey = `loadout_overlay_${config.channel}`;
                const storedLoadout = localStorage.getItem(storageKey);

                // Log every 10th check to avoid spam
                if (updateCount++ % 10 === 0) {
                    console.log(`Checking localStorage key: ${storageKey}, found:`, storedLoadout ? 'yes' : 'no');
                }

                if (storedLoadout) {
                    const loadout = JSON.parse(storedLoadout);
                    // Only update if loadout changed
                    if (JSON.stringify(loadout) !== JSON.stringify(lastLoadout)) {
                        console.log('📦 New loadout detected in localStorage!');
                        lastLoadout = loadout;
                        renderLoadout(loadout);
                    }
                }

                // Also check for loadout in URL (for direct linking)
                const urlLoadout = params.get('loadout');
                if (urlLoadout) {
                    try {
                        const loadout = JSON.parse(decodeURIComponent(urlLoadout));
                        if (JSON.stringify(loadout) !== JSON.stringify(lastLoadout)) {
                            lastLoadout = loadout;
                            renderLoadout(loadout);
                        }
                    } catch (e) {
                        console.error('Failed to parse URL loadout:', e);
                    }
                }
            } catch (e) {
                console.error('Error checking for updates:', e);
            }
        }

        // Listen for storage events (updates from main site)
        window.addEventListener('storage', (e) => {
            if (e.key === `loadout_overlay_${config.channel}`) {
                checkForUpdates();
            }
        });

        // Initial check - with delay to ensure everything is loaded
        setTimeout(() => {
            console.log('🔍 Running initial check for existing loadout');
            checkForUpdates();

            // Also check a default key for OBS compatibility
            const defaultLoadout = localStorage.getItem('loadout_overlay_default');
            if (defaultLoadout && !lastLoadout) {
                console.log('📦 Found default loadout for OBS');
                try {
                    const loadout = JSON.parse(defaultLoadout);
                    renderLoadout(loadout);
                } catch (e) {
                    console.error('Failed to parse default loadout:', e);
                }
            }
        }, 500);

        // Regular polling as backup - more frequent for better responsiveness
        setInterval(checkForUpdates, 250); // Check every 250ms instead of 500ms

        // Listen for postMessage from parent window (for iframe preview)
        window.addEventListener('message', (event) => {
            console.log('📨 Overlay received postMessage from:', event.origin);
            console.log('Message data:', event.data);

            // Handle ping messages for testing
            if (event.data && event.data.type === 'ping') {
                console.log('🏓 Received ping:', event.data.message);
                // Send pong back
                if (event.source) {
                    event.source.postMessage({ type: 'pong', message: 'Overlay ready' }, event.origin);
                }
            }

            // Accept messages from any origin in production (be careful with this in real production)
            if (event.data && event.data.type === 'loadout_update' && event.data.payload) {
                console.log('✅ Processing loadout from postMessage');
                renderLoadout(event.data.payload);
            }
        });

        // Log initial state with more detail
        console.log('🎮 Stream overlay initialized');
        console.log('Channel ID:', channelId);
        console.log('Config:', config);
        console.log('Window location:', window.location.href);
        console.log('Parent location:', window.parent !== window ? 'Has parent frame' : 'No parent frame');

        // Direct method for parent window to send loadout
        window.receiveLoadout = function(loadout) {
            console.log('📦 Received loadout via direct call:', loadout);
            renderLoadout(loadout);
        };

        // Test function for development
        window.testLoadout = function() {
            const classes = ['Light', 'Medium', 'Heavy'];
            const weapons = {
                Light: ['V9S', 'XP-54', 'M11', 'LH1', 'Dagger', 'Sword', 'Throwing Knives'],
                Medium: ['FCAR', 'AKM', 'R.357', 'Model 1887', 'FAMAS'],
                Heavy: ['SA1216', 'M60', 'Lewis Gun', 'Flamethrower', 'Sledgehammer']
            };
            const specializations = {
                Light: ['Evasive Dash', 'Grappling Hook', 'Cloaking Device'],
                Medium: ['Guardian Turret', 'Healing Beam', 'Dematerializer'],
                Heavy: ['Mesh Shield', 'Charge \'n\' Slam', 'Goo Gun']
            };
            const gadgets = ['Frag Grenade', 'Gas Grenade', 'Goo Grenade', 'Flashbang', 'Smoke Grenade', 'C4', 'RPG', 'Defibrillator'];

            const selectedClass = classes[Math.floor(Math.random() * classes.length)];
            const classWeapons = weapons[selectedClass];
            const classSpecs = specializations[selectedClass];

            const testData = {
                class: selectedClass,
                name: 'Test Loadout',
                weapon: {
                    name: classWeapons[Math.floor(Math.random() * classWeapons.length)],
                    image: '/images/weapons/fcar.png'  // Example image path
                },
                specialization: {
                    name: classSpecs[Math.floor(Math.random() * classSpecs.length)],
                    image: '/images/specializations/healing-beam.png'  // Example image path
                },
                gadgets: [
                    { name: gadgets[Math.floor(Math.random() * gadgets.length)], image: '/images/gadgets/frag.png' },
                    { name: gadgets[Math.floor(Math.random() * gadgets.length)], image: null },
                    { name: gadgets[Math.floor(Math.random() * gadgets.length)], image: null }
                ],
                timestamp: new Date().toISOString()
            };
            localStorage.setItem(`loadout_overlay_${config.channel}`, JSON.stringify(testData));
        };
    </script>

    <!-- Supabase Integration (Optional - will fallback to localStorage if not available) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase if available
        let supabaseOverlay = null;
        let channelOverlay = null;

        if (typeof window.supabase !== 'undefined') {
            try {
                // Initialize Supabase - MUST match the stream-tools page credentials
                const SUPABASE_URL = 'https://nabbbidjnmljaadmjjln.supabase.co';
                const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5hYmJiaWRqbm1samFhZG1qamxuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzcxNTI2MDAsImV4cCI6MjA1MjcyODYwMH0.C-apFqin1kBOOV8L3R8Y0cakcAU2A8KtFqQr2PwVHAc';
                supabaseOverlay = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('Supabase client created successfully');
            } catch (e) {
                console.log('Failed to initialize Supabase:', e);
            }
        } else {
            console.log('Supabase library not loaded, using localStorage/BroadcastChannel fallback');
        }

        // Get channel from URL parameters - use same channel name as sender
        const channelId = config.channel || 'default';
        const channelName = channelId; // Use the channel ID directly, not 'overlay_' prefix

        // Only try Supabase if it was successfully initialized
        if (supabaseOverlay) {
            try {
                // Listen for loadout updates on the specific channel
                channelOverlay = supabaseOverlay.channel(channelName);

                channelOverlay
                    .on('broadcast', { event: 'loadout_update' }, (payload) => {
                        console.log(`✅ Received loadout from Supabase on channel: ${channelName}`, payload);
                        renderLoadout(payload.payload);
                    })
                    .subscribe((status) => {
                        if (status === 'SUBSCRIBED') {
                            console.log(`✅ Connected to Supabase channel: ${channelName}! Waiting for loadouts...`);
                        }
                    });
            } catch (e) {
                console.log('Supabase connection failed, falling back to localStorage/BroadcastChannel', e);
            }
        }
    </script>
</body>
</html>