<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE FINALS Loadout - OBS Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            color: #fff;
            overflow: hidden;
            position: relative;
            width: 600px;
            height: 180px;
            margin: 0;
            padding: 0;
        }

        /* Slot Machine Style Container */
        .overlay-container {
            position: absolute;
            background: linear-gradient(135deg, rgba(20, 10, 25, 0.98) 0%, rgba(35, 20, 40, 0.95) 100%);
            border-radius: 8px;
            border: 1px solid rgba(255, 71, 150, 0.4);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.9);
            transition: all 0.3s ease;
            width: 540px;
            height: 160px;
            padding: 8px 8px 12px 8px;
            top: 5px;
            left: 10px;
        }

        /* Position presets */
        .top-left { top: 10px; left: 10px; }
        .top-right { top: 10px; right: 10px; }
        .bottom-left { bottom: 10px; left: 10px; }
        .bottom-right { bottom: 10px; right: 10px; }
        .center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Theme presets */
        .theme-dark {
            background: linear-gradient(135deg, rgba(20, 10, 25, 0.98) 0%, rgba(35, 20, 40, 0.95) 100%);
            border-color: rgba(255, 71, 150, 0.4);
        }

        .theme-light {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(240, 240, 240, 0.9) 100%);
            color: #000;
            border-color: rgba(0, 0, 0, 0.2);
        }

        .theme-light .column-header {
            color: #8B0038 !important;  /* Much darker pink/burgundy for better contrast */
            font-size: 11px !important;  /* Slightly larger text */
            font-weight: 900 !important;  /* Bolder text */
        }

        .theme-finals {
            background: linear-gradient(135deg, rgba(228, 49, 79, 0.95) 0%, rgba(200, 30, 60, 0.9) 100%);
            border-color: rgba(228, 49, 79, 0.5);
        }

        .theme-finals .column-header {
            color: #ffffff !important;
        }

        .theme-finals .site-branding {
            background: none;
            -webkit-text-fill-color: #ffffff;
        }

        .theme-finals .class-name {
            color: #ffffff !important;
        }

        .theme-finals .item-name {
            color: #ffffff !important;
        }

        .theme-transparent {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 71, 150, 0.4);
            backdrop-filter: blur(10px);
        }

        /* Class Header */
        .class-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: linear-gradient(90deg, rgba(255, 71, 150, 0.15) 0%, rgba(150, 71, 255, 0.1) 100%);
            border-radius: 5px;
        }

        .class-name {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .site-branding {
            font-size: 16px;
            background: linear-gradient(90deg, #ff4796, #ff71b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .class-light { color: #ff4796; }
        .class-medium { color: #9b59b6; }
        .class-heavy { color: #3498db; }

        /* Slot Machine Columns */
        .slot-columns {
            display: flex;
            gap: 0;
            justify-content: center;
            padding: 0;
        }

        .slot-column {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 71, 150, 0.2);
            border-right: none;
            padding: 6px;
            min-width: 100px;
            flex: 1;
            transition: transform 0.3s ease;
        }

        .slot-column:first-child {
            border-radius: 6px 0 0 6px;
        }

        .slot-column:last-child {
            border-radius: 0 6px 6px 0;
            border-right: 1px solid rgba(255, 71, 150, 0.2);
        }

        .slot-column:hover {
            transform: translateY(-2px);
            border-color: rgba(255, 71, 150, 0.4);
        }

        .column-header {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
            margin-bottom: 6px;
            color: #ff71b0;
            font-weight: bold;
        }

        .item-display {
            background: rgba(255, 71, 150, 0.06);
            border: 1px solid rgba(255, 71, 150, 0.15);
            border-radius: 4px;
            padding: 4px;
            text-align: center;
            height: 72px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .item-image {
            width: 48px;
            height: 48px;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.7));
            transition: transform 0.2s ease;
        }

        .item-image:hover {
            transform: scale(1.1);
        }

        .item-name {
            font-size: 9px;
            font-weight: 500;
            line-height: 1.1;
            word-wrap: break-word;
            max-width: 100%;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 2px;
        }

        /* Animations */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 71, 150, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 71, 150, 0.8); }
        }

        .animate-in {
            animation: slideIn 0.5s ease;
        }

        .new-loadout .item-display {
            animation: glow 1s ease-in-out;
        }

        /* Compact mode - text only, horizontal layout */
        .compact {
            width: auto;
            height: auto;
            padding: 10px 15px;
        }

        .compact .slot-columns {
            flex-direction: row;
            gap: 20px;
            align-items: center;
        }

        .compact .slot-column-compact {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 0 10px;
            border-right: 1px solid rgba(255, 71, 150, 0.2);
        }

        .compact .slot-column-compact:last-child {
            border-right: none;
        }

        .compact .compact-label {
            font-weight: bold;
            color: #ff4796;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 1px;
        }

        .compact .compact-name {
            color: #fff;
            font-weight: 600;
            font-size: 14px;
            white-space: nowrap;
        }

        .compact .class-header {
            margin-bottom: 10px;
        }

        .compact .class-name {
            font-size: 14px;
        }

        .compact .site-branding {
            font-size: 9px;
        }

        .compact .class-header {
            padding: 4px 8px;
            margin-bottom: 4px;
        }

        .compact .class-name {
            font-size: 14px;
        }

        .compact .site-branding {
            font-size: 14px;
        }

        .compact .slot-columns {
            padding: 0;
            gap: 0;
        }

        .compact .slot-column {
            min-width: 85px;
            padding: 6px;
        }

        .compact .column-header {
            font-size: 8px;
            margin-bottom: 4px;
        }

        .compact .item-display {
            padding: 4px;
            height: 65px;
            gap: 2px;
        }

        .compact .item-image {
            width: 40px;
            height: 40px;
        }

        .compact .item-name {
            font-size: 9px;
        }

        /* Hidden state */
        .hidden {
            display: none;
        }

        /* No loadout state */
        .no-loadout {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
        }

        .waiting-text {
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #ff4796, #ff71b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }

        /* Theme-specific waiting text */
        .theme-light .waiting-text {
            background: linear-gradient(90deg, #8B0038, #d4005f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .theme-finals .waiting-text {
            background: none;
            -webkit-text-fill-color: #ffffff;
        }

        .theme-transparent .waiting-text {
            background: linear-gradient(90deg, rgba(255, 71, 150, 0.9), rgba(255, 113, 176, 0.9));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .theme-light .no-loadout {
            color: rgba(0, 0, 0, 0.7);
        }

        .theme-light .no-loadout p {
            color: rgba(0, 0, 0, 0.6);
        }

        /* Light theme text contrast improvements */
        .theme-light .class-name {
            color: #000000 !important;
        }

        .theme-light .item-name {
            color: rgba(0, 0, 0, 0.8) !important;
        }

        .theme-light .site-branding {
            color: rgba(0, 0, 0, 0.6) !important;
        }

        /* Loading dots animation */
        .loading-dots {
            display: inline-block;
        }

        .loading-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Fallback for missing images */
        .item-icon-fallback {
            width: 60px;
            height: 60px;
            background: rgba(255, 107, 53, 0.2);
            border: 2px solid rgba(255, 107, 53, 0.4);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ff6b35;
        }

        .compact .item-icon-fallback {
            width: 45px;
            height: 45px;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="overlayContainer" class="overlay-container theme-dark" style="display: block !important; visibility: visible !important; opacity: 1 !important;">
        <div class="no-loadout">
            <div class="class-header">
                <div class="waiting-text">WAITING FOR LOADOUT</div>
                <div class="site-branding">TheFinalsLoadout.com ‚Ä¢ Live</div>
            </div>
            <div style="padding: 20px; text-align: center;">
                <p style="margin: 0; color: rgba(255, 255, 255, 0.7); font-size: 12px;">Generate a loadout to display here</p>
            </div>
        </div>
    </div>

    <script>
        console.log('üöÄ Overlay script starting...');

        // Detect context - are we in an iframe (preview) or OBS?
        const isIframe = window.parent !== window;
        const context = isIframe ? 'PREVIEW' : 'OBS';
        console.log(`üìç Running in ${context} mode`);

        // Debug: Check if container exists
        window.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('overlayContainer');
            console.log('Container found:', !!container);
            if (container) {
                console.log('Container display:', window.getComputedStyle(container).display);
                console.log('Container visibility:', window.getComputedStyle(container).visibility);
                console.log('Container dimensions:', container.offsetWidth, 'x', container.offsetHeight);
            }
        });

        // Configuration from URL parameters
        const params = new URLSearchParams(window.location.search);

        // Check localStorage for saved config (from stream-tools)
        let savedConfig = {};
        try {
            const configStr = localStorage.getItem('overlayConfig');
            if (configStr) {
                savedConfig = JSON.parse(configStr);
                console.log('Loaded saved config:', savedConfig);
            }
        } catch (e) {
            console.log('No saved config found');
        }

        // Also check localStorage for compact mode
        const storedCompact = localStorage.getItem('overlayCompactMode');
        console.log('Stored compact mode from localStorage:', storedCompact);

        // Simplified config - only channel from URL, everything else from localStorage
        const config = {
            theme: savedConfig.theme || 'dark',
            compact: storedCompact !== null ? (storedCompact === 'true' || storedCompact === true) : (savedConfig.compact === 'true' || savedConfig.compact === false),
            channel: params.get('channel') || 'default',  // Only URL param we need
            animate: true
        };

        console.log('Initial config loaded - Compact mode:', config.compact, 'Type:', typeof config.compact);

        // Apply configuration
        const container = document.getElementById('overlayContainer');
        container.className = `overlay-container theme-${config.theme}${config.compact ? ' compact' : ''}`;

        // Make sure the container is visible initially
        console.log('üéÆ Overlay initialized with config:', config);

        // Show waiting message initially (default state)
        container.style.display = 'block';
        container.style.opacity = '1';
        container.style.visibility = 'visible';
        console.log('‚úÖ Container made visible with waiting message');

        // Icon fallbacks for different item types
        const itemIcons = {
            weapon: 'üî´',
            specialization: '‚ö°',
            gadget: 'üéØ'
        };

        // Function to create item HTML with image or fallback
        function createItemHTML(item, type, index, isLast = false, forceCompact = null) {
            const name = typeof item === 'object' ? item.name : item;
            const image = typeof item === 'object' ? item.image : null;

            // Use explicit compact parameter if provided, otherwise check global config
            const isCompact = forceCompact !== null ? forceCompact : config.compact;

            console.log(`Creating item HTML for ${name} - Compact: ${isCompact}`);

            const headerText = type === 'gadget' ? `GADGET ${index + 1}` : type.toUpperCase();

            if (isCompact === true || isCompact === 'true') {
                // Compact text-only version with inline styles for OBS
                const borderStyle = isLast ? '' : 'border-right: 1px solid rgba(255, 71, 150, 0.2);';

                // Adjust text colors based on theme
                let labelColor = '#ff4796'; // Default pink
                let nameColor = '#fff'; // Default white
                let borderColor = 'rgba(255, 71, 150, 0.2)'; // Default pink border

                if (config.theme === 'light') {
                    labelColor = '#d1004b'; // Darker pink for light theme
                    nameColor = '#000'; // Black text for light theme
                    borderColor = 'rgba(0, 0, 0, 0.2)'; // Dark border
                } else if (config.theme === 'finals') {
                    labelColor = '#000'; // Black labels for red theme
                    nameColor = '#fff'; // White text for contrast
                    borderColor = 'rgba(0, 0, 0, 0.3)'; // Black border
                }

                const adjustedBorderStyle = isLast ? '' : `border-right: 1px solid ${borderColor};`;

                return `
                    <div class="slot-column-compact" style="display: flex; flex-direction: column; align-items: center; gap: 4px; padding: 0 8px; min-width: 80px; ${adjustedBorderStyle}">
                        <span class="compact-label" style="font-weight: bold; color: ${labelColor}; text-transform: uppercase; font-size: 10px; letter-spacing: 0.5px; white-space: nowrap;">${headerText}</span>
                        <span class="compact-name" style="color: ${nameColor}; font-weight: 600; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100px;">${name || 'None'}</span>
                    </div>
                `;
            } else {
                // Normal mode - show images
                let imageHTML;
                console.log(`Item: ${name}, Image path: ${image}`); // Debug log

                if (image && image !== 'null' && image !== null) {
                    // Fix relative paths for images
                    let imageSrc = image;
                    if (image.startsWith('../images/')) {
                        // Convert relative path from stream-tools context to overlay context
                        imageSrc = image.replace('../images/', '/images/');
                    }
                    // Try to load the image with debugging
                    imageHTML = `<img class="item-image" src="${imageSrc}" alt="${name}"
                                onload="console.log('‚úÖ Loaded: ${name}')"
                                onerror="console.error('‚ùå Failed to load: ${name} from ${imageSrc}'); this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                <div class="item-icon-fallback" style="display:none;">${itemIcons[type] || 'üì¶'}</div>`;
                } else {
                    // Use fallback icon
                    console.log(`No image for ${name}, using fallback icon`);
                    imageHTML = `<div class="item-icon-fallback">${itemIcons[type] || 'üì¶'}</div>`;
                }

                return `
                    <div class="slot-column">
                        <div class="column-header">${headerText}</div>
                        <div class="item-display">
                            ${imageHTML}
                            <div class="item-name">${name || 'Empty'}</div>
                        </div>
                    </div>
                `;
            }
        }

        // Function to render loadout in slot machine style
        function renderLoadout(loadout) {
            console.log('üé∞ Rendering loadout:', loadout); // Debug the entire loadout
            console.log('üéÆ Current compact mode:', config.compact, typeof config.compact);

            // Save the loadout for re-rendering
            lastLoadout = loadout;

            // Check for null/empty loadout
            if (!loadout) {
                console.log('‚ùå No loadout provided - showing waiting message');
                container.classList.remove('hidden');
                container.innerHTML = `
                    <div class="no-loadout">
                        <div class="class-header">
                            <div class="waiting-text">WAITING FOR LOADOUT</div>
                            <div class="site-branding">TheFinalsLoadout.com ‚Ä¢ Live</div>
                        </div>
                        <div style="padding: 20px; text-align: center;">
                            <p style="margin: 0; color: rgba(255, 255, 255, 0.7); font-size: 12px;">Generate a loadout to display here</p>
                        </div>
                    </div>
                `;
                return;
            }

            // Check for reset/placeholder state - allow it to pass through
            const isReset = loadout.type === 'reset' || loadout.class === 'EMPTY';
            if (isReset) {
                console.log('üîÑ Rendering reset/placeholder loadout');
            }

            // Check for invalid loadout (but allow reset state)
            if (!isReset && !loadout.class) {
                console.log('‚ùå Invalid loadout - missing class');
                container.classList.remove('hidden');
                container.innerHTML = `
                    <div class="no-loadout">
                        <div class="class-header">
                            <div class="waiting-text">WAITING FOR LOADOUT</div>
                            <div class="site-branding">TheFinalsLoadout.com ‚Ä¢ Live</div>
                        </div>
                        <div style="padding: 20px; text-align: center;">
                            <p style="margin: 0; color: rgba(255, 255, 255, 0.7); font-size: 12px;">Generate a loadout to display here</p>
                        </div>
                    </div>
                `;
                return;
            }

            // Normalize loadout format (handle both old and new formats)
            const normalizedLoadout = {
                class: loadout.class,
                name: loadout.name || 'Generated Loadout',
                weapon: typeof loadout.weapon === 'string'
                    ? { name: loadout.weapon, image: `/images/${loadout.weapon.replace(/ /g, '_')}.webp` }
                    : loadout.weapon,
                specialization: typeof loadout.specialization === 'string'
                    ? { name: loadout.specialization, image: `/images/${loadout.specialization.replace(/ /g, '_')}.webp` }
                    : loadout.specialization,
                gadgets: []
            };

            // Handle gadgets in various formats
            if (loadout.gadgets && Array.isArray(loadout.gadgets)) {
                normalizedLoadout.gadgets = loadout.gadgets.map(g =>
                    typeof g === 'string' ? { name: g, image: `/images/${g.replace(/ /g, '_')}.webp` } : g
                );
            } else if (loadout.gadget1 || loadout.gadget2 || loadout.gadget3) {
                // Handle old format with gadget1, gadget2, gadget3
                if (loadout.gadget1) normalizedLoadout.gadgets.push({ name: loadout.gadget1, image: `/images/${loadout.gadget1.replace(/ /g, '_')}.webp` });
                if (loadout.gadget2) normalizedLoadout.gadgets.push({ name: loadout.gadget2, image: `/images/${loadout.gadget2.replace(/ /g, '_')}.webp` });
                if (loadout.gadget3) normalizedLoadout.gadgets.push({ name: loadout.gadget3, image: `/images/${loadout.gadget3.replace(/ /g, '_')}.webp` });
            }

            console.log('üì¶ Normalized loadout:', normalizedLoadout);
            loadout = normalizedLoadout;

            container.classList.remove('hidden');

            const classLower = (loadout.class || 'unknown').toLowerCase();

            // Build columns HTML
            let columnsHTML = '';

            // Calculate total items for isLast parameter
            const gadgetCount = loadout.gadgets && loadout.gadgets.length > 0 ? loadout.gadgets.length : 1;
            const totalItems = 2 + gadgetCount; // weapon + spec + gadgets

            // Explicitly pass compact mode to ensure it's used
            const compactMode = config.compact === true || config.compact === 'true';
            console.log('üéØ Passing compact mode to createItemHTML:', compactMode);

            // Weapon column
            columnsHTML += createItemHTML(loadout.weapon, 'weapon', 0, false, compactMode);

            // Specialization column
            columnsHTML += createItemHTML(loadout.specialization, 'specialization', 0, gadgetCount === 0, compactMode);

            // Gadgets columns
            if (loadout.gadgets && loadout.gadgets.length > 0) {
                loadout.gadgets.forEach((gadget, index) => {
                    const isLastGadget = index === loadout.gadgets.length - 1;
                    columnsHTML += createItemHTML(gadget, 'gadget', index, isLastGadget, compactMode);
                });
            } else {
                columnsHTML += createItemHTML('None', 'gadget', 0, true, compactMode);
            }

            // Add inline styles for compact mode to ensure OBS renders correctly
            const compactStyles = compactMode ? 'style="display: flex; flex-direction: row; gap: 12px; align-items: center; justify-content: center;"' : '';

            // Adjust header text colors based on theme
            let headerTextColor = '';
            let brandingColor = '';

            if (compactMode) {
                if (config.theme === 'light') {
                    headerTextColor = 'color: #000;'; // Black text for light theme
                    brandingColor = 'color: #666;'; // Dark gray for branding
                } else if (config.theme === 'finals') {
                    headerTextColor = 'color: #000;'; // Black text for red theme
                    brandingColor = 'color: rgba(0, 0, 0, 0.7);'; // Semi-black for branding
                } else {
                    headerTextColor = ''; // Default (white)
                    brandingColor = ''; // Default
                }
            }

            // Handle header text for reset state
            const headerText = isReset ? 'READY' : `${loadout.class} BUILD`;
            const headerClass = isReset ? 'ready' : `class-${classLower}`;

            const loadoutHTML = `
                <div class="class-header" ${compactMode ? 'style="margin-bottom: 10px; padding: 4px 8px;"' : ''}>
                    <div class="class-name ${headerClass}" ${compactMode ? `style="font-size: 14px; ${headerTextColor}"` : ''}>${headerText}</div>
                    <div class="site-branding" ${compactMode ? `style="font-size: 9px; ${brandingColor}"` : ''}>TheFinalsLoadout.com</div>
                </div>
                <div class="slot-columns" ${compactStyles}>
                    ${columnsHTML}
                </div>
            `;

            // Update container class based on actual compact mode
            container.className = `overlay-container theme-${config.theme || 'dark'}${compactMode ? ' compact' : ''}`;

            container.innerHTML = loadoutHTML;

            // Apply compact container styles inline for OBS
            if (compactMode) {
                container.style.width = 'auto';
                container.style.height = 'auto';
                container.style.padding = '10px 15px';
                console.log('‚úÖ Applied compact container styles');
            } else {
                // Reset to default styles
                container.style.width = '';
                container.style.height = '';
                container.style.padding = '';
                console.log('‚úÖ Applied normal container styles');
            }

            if (config.animate) {
                container.classList.add('animate-in', 'new-loadout');
                setTimeout(() => {
                    container.classList.remove('animate-in', 'new-loadout');
                }, 1000);
            }
        }

        // REMOVED: BroadcastChannel - using Supabase for OBS, postMessage for preview

        // Track the last loadout for comparison
        let lastLoadout = null;

        // REMOVED: checkForUpdates function - no longer polling localStorage
        function checkForUpdates() {
            try {
                // Check localStorage for current loadout
                const storageKey = `loadout_overlay_${config.channel}`;
                const storedLoadout = localStorage.getItem(storageKey);

                // Log every 10th check to avoid spam
                if (updateCount++ % 10 === 0) {
                    console.log(`Checking localStorage key: ${storageKey}, found:`, storedLoadout ? 'yes' : 'no');
                }

                if (storedLoadout) {
                    const loadout = JSON.parse(storedLoadout);
                    // Only update if loadout changed
                    if (JSON.stringify(loadout) !== JSON.stringify(lastLoadout)) {
                        console.log('üì¶ New loadout detected in localStorage!');
                        lastLoadout = loadout;
                        renderLoadout(loadout);
                    }
                }

                // Also check for loadout in URL (for direct linking)
                const urlLoadout = params.get('loadout');
                if (urlLoadout) {
                    try {
                        const loadout = JSON.parse(decodeURIComponent(urlLoadout));
                        if (JSON.stringify(loadout) !== JSON.stringify(lastLoadout)) {
                            lastLoadout = loadout;
                            renderLoadout(loadout);
                        }
                    } catch (e) {
                        console.error('Failed to parse URL loadout:', e);
                    }
                }

                // Check for simple URL parameters (for OBS)
                const urlClass = params.get('class');
                const urlWeapon = params.get('weapon');
                if (urlClass && urlWeapon && !lastLoadout) {
                    const simpleLoadout = {
                        class: urlClass,
                        weapon: { name: decodeURIComponent(urlWeapon) },
                        specialization: { name: decodeURIComponent(params.get('spec') || 'None') },
                        gadgets: []
                    };
                    if (params.get('g1')) simpleLoadout.gadgets.push({ name: decodeURIComponent(params.get('g1')) });
                    if (params.get('g2')) simpleLoadout.gadgets.push({ name: decodeURIComponent(params.get('g2')) });
                    if (params.get('g3')) simpleLoadout.gadgets.push({ name: decodeURIComponent(params.get('g3')) });
                    console.log('üì¶ Built loadout from URL params:', simpleLoadout);
                    renderLoadout(simpleLoadout);
                }
            } catch (e) {
                console.error('Error checking for updates:', e);
            }
        }

        // Listen for storage events (updates from main site)
        window.addEventListener('storage', (e) => {
            // Listen for config changes
            if (e.key === 'overlayConfig' && e.newValue) {
                try {
                    const newConfig = JSON.parse(e.newValue);
                    console.log('Config updated via storage:', newConfig);

                    // Update global config
                    if (newConfig.compact !== undefined) {
                        config.compact = newConfig.compact === 'true' || newConfig.compact === true;
                    }
                    if (newConfig.theme !== undefined) {
                        config.theme = newConfig.theme;
                    }
                    // hideEmpty feature removed - always shows waiting message when empty

                    // Apply new theme/position immediately
                    const container = document.getElementById('overlayContainer');
                    if (container) {
                        container.className = `overlay-container theme-${config.theme || 'dark'}${config.compact ? ' compact' : ''}`;
                        console.log('Applied new theme:', config.theme);
                        console.log('Compact mode:', config.compact);

                        // Re-render with new compact setting
                        if (lastLoadout) {
                            renderLoadout(lastLoadout);
                        }
                    }
                } catch (err) {
                    console.error('Failed to parse config:', err);
                }
                return;
            }

            // REMOVED: No longer checking for loadout changes in localStorage
        });

        // REMOVED: Initial localStorage check - no longer needed

        // REMOVED: localStorage polling - using real-time updates only

        // Listen for postMessage from parent window (ONLY for iframe preview)
        if (isIframe) {
            window.addEventListener('message', (event) => {
                console.log('üì® Preview received postMessage from:', event.origin);
                console.log('Message data:', event.data);

                // Handle ping messages for testing
                if (event.data && event.data.type === 'ping') {
                    console.log('üèì Received ping:', event.data.message);
                    // Send pong back
                    if (event.source) {
                        event.source.postMessage({ type: 'pong', message: 'Overlay ready' }, event.origin);
                    }
                }

                // Accept loadout updates ONLY in iframe mode
                if (event.data && event.data.type === 'loadout_update') {
                    console.log('‚úÖ Processing loadout from postMessage');
                    // Payload can be null when resetting
                    renderLoadout(event.data.payload);
                }
            });
            console.log('‚úÖ Preview mode: Listening to postMessage only');
        }

        // Get channel from URL first (using params already declared above)
        const channelId = params.get('channel') || 'default';

        // Log initial state with more detail
        console.log('üéÆ Stream overlay initialized at', new Date().toISOString());
        console.log('Channel ID:', channelId);
        console.log('Config:', config);
        console.log('Window location:', window.location.href);
        console.log('Parent location:', window.parent !== window ? 'Has parent frame' : 'No parent frame');
        console.log('LocalStorage available:', typeof(Storage) !== "undefined");

        // Check for existing data on load
        const existingData = localStorage.getItem(`loadout_overlay_${channelId}`);
        const defaultData = localStorage.getItem('loadout_overlay_default');
        console.log('Existing channel data:', existingData ? 'Found' : 'Not found');
        console.log('Default data:', defaultData ? 'Found' : 'Not found');

        // Add a visible indicator that script is running
        if (window.location.search.includes('debug=true')) {
            const debugDiv = document.createElement('div');
            debugDiv.style.cssText = 'position: fixed; top: 0; right: 0; background: lime; color: black; padding: 5px; z-index: 9999;';
            debugDiv.textContent = 'Overlay Script Running';
            document.body.appendChild(debugDiv);
        }

        // Direct method for parent window to send loadout
        window.receiveLoadout = function(loadout) {
            console.log('üì¶ Received loadout via direct call:', loadout);
            renderLoadout(loadout);
        };

        // Test function for development
        window.testLoadout = function() {
            const classes = ['Light', 'Medium', 'Heavy'];
            const weapons = {
                Light: ['V9S', 'XP-54', 'M11', 'LH1', 'Dagger', 'Sword', 'Throwing Knives'],
                Medium: ['FCAR', 'AKM', 'R.357', 'Model 1887', 'FAMAS'],
                Heavy: ['SA1216', 'M60', 'Lewis Gun', 'Flamethrower', 'Sledgehammer']
            };
            const specializations = {
                Light: ['Evasive Dash', 'Grappling Hook', 'Cloaking Device'],
                Medium: ['Guardian Turret', 'Healing Beam', 'Dematerializer'],
                Heavy: ['Mesh Shield', 'Charge \'n\' Slam', 'Goo Gun']
            };
            const gadgets = ['Frag Grenade', 'Gas Grenade', 'Goo Grenade', 'Flashbang', 'Smoke Grenade', 'C4', 'RPG', 'Defibrillator'];

            const selectedClass = classes[Math.floor(Math.random() * classes.length)];
            const classWeapons = weapons[selectedClass];
            const classSpecs = specializations[selectedClass];

            const testData = {
                class: selectedClass,
                name: 'Test Loadout',
                weapon: {
                    name: classWeapons[Math.floor(Math.random() * classWeapons.length)],
                    image: '/images/weapons/fcar.png'  // Example image path
                },
                specialization: {
                    name: classSpecs[Math.floor(Math.random() * classSpecs.length)],
                    image: '/images/specializations/healing-beam.png'  // Example image path
                },
                gadgets: [
                    { name: gadgets[Math.floor(Math.random() * gadgets.length)], image: '/images/gadgets/frag.png' },
                    { name: gadgets[Math.floor(Math.random() * gadgets.length)], image: null },
                    { name: gadgets[Math.floor(Math.random() * gadgets.length)], image: null }
                ],
                timestamp: new Date().toISOString()
            };
            localStorage.setItem(`loadout_overlay_${config.channel}`, JSON.stringify(testData));
        };
    </script>

    <!-- Supabase Integration (Optional - will fallback to localStorage if not available) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase if available
        let supabaseOverlay = null;
        let channelOverlay = null;

        if (typeof window.supabase !== 'undefined') {
            try {
                // Initialize Supabase - MUST match the stream-tools page credentials
                const SUPABASE_URL = 'https://lalgvijlctrxbqtsctum.supabase.co';
                const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxhbGd2aWpsY3RyeGJxdHNjdHVtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkwMzM4NzAsImV4cCI6MjA3NDYwOTg3MH0.GexJt5wtdif5H-QTFExzuukOVZToa9_tRpbl9RrEiQ4';
                supabaseOverlay = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
                    realtime: {
                        params: {
                            log_level: 'info'
                        }
                    }
                });
                console.log('Supabase client created successfully');
            } catch (e) {
                console.log('Failed to initialize Supabase:', e);
            }
        } else {
            console.log('Supabase library not loaded, using localStorage/BroadcastChannel fallback');
        }

        // Get channel ID for Supabase
        const urlParams = new URLSearchParams(window.location.search);
        const supabaseChannelId = urlParams.get('channel') || 'default';
        const channelName = supabaseChannelId; // Use the channel ID directly, not 'overlay_' prefix

        // Only use Supabase if in OBS mode (not iframe preview)
        if (supabaseOverlay && !isIframe) {
            console.log('üé¨ OBS mode: Listening to Supabase only');
            try {
                // ALWAYS listen to obs_default channel for OBS
                const obsChannel = supabaseOverlay.channel('obs_default');

                // Also listen for config updates
                const configChannel = supabaseOverlay.channel('obs_config');
                configChannel
                    .on('broadcast', { event: 'config_update' }, (payload) => {
                        console.log('üì® Received config update:', payload.payload);
                        const newConfig = payload.payload;

                        // Update global config
                        if (newConfig.compact !== undefined) {
                            config.compact = newConfig.compact === 'true' || newConfig.compact === true;
                            console.log('Updated compact mode:', config.compact);

                            // Store in localStorage for persistence (as string)
                            localStorage.setItem('overlayCompactMode', String(config.compact));

                            // Visual debug indicator for OBS
                            document.body.style.border = config.compact ? '3px solid yellow' : '3px solid green';
                            setTimeout(() => { document.body.style.border = 'none'; }, 2000);
                        }
                        if (newConfig.theme !== undefined) {
                            config.theme = newConfig.theme;
                        }
                        // hideEmpty feature removed - always shows waiting message when empty

                        const container = document.getElementById('overlayContainer');
                        if (container && newConfig) {
                            // Update the class
                            container.className = `overlay-container theme-${config.theme || 'dark'}${config.compact ? ' compact' : ''}`;

                            // Force style updates based on theme
                            if (config.theme === 'light') {
                                container.style.background = 'linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(240, 240, 240, 0.9) 100%)';
                                container.style.color = '#000';
                                container.style.borderColor = 'rgba(0, 0, 0, 0.2)';
                            } else if (config.theme === 'finals') {
                                container.style.background = 'linear-gradient(135deg, rgba(228, 49, 79, 0.95) 0%, rgba(200, 30, 60, 0.9) 100%)';
                                container.style.borderColor = 'rgba(228, 49, 79, 0.5)';
                            } else if (config.theme === 'transparent') {
                                container.style.background = 'rgba(0, 0, 0, 0.6)';
                                container.style.border = '2px solid rgba(255, 71, 150, 0.4)';
                            } else { // dark theme (default)
                                container.style.background = 'linear-gradient(135deg, rgba(20, 10, 25, 0.98) 0%, rgba(35, 20, 40, 0.95) 100%)';
                                container.style.borderColor = 'rgba(255, 71, 150, 0.4)';
                                container.style.color = '#fff';
                            }

                            // Re-render the current loadout with new compact setting
                            if (lastLoadout) {
                                console.log('Re-rendering loadout with compact mode:', config.compact);
                                renderLoadout(lastLoadout);
                            }

                            // Force a more aggressive repaint in OBS
                            // Add a timestamp to force cache invalidation
                            container.setAttribute('data-refresh', Date.now());

                            // Multiple reflow triggers for OBS
                            container.style.opacity = '0.99';
                            container.offsetHeight; // Trigger reflow
                            container.style.opacity = '1';

                            container.style.display = 'none';
                            container.offsetHeight; // Trigger reflow
                            container.style.display = 'block';

                            // Also toggle visibility
                            container.style.visibility = 'hidden';
                            setTimeout(() => {
                                container.style.visibility = 'visible';
                            }, 10);

                            console.log('‚úÖ Applied config - Theme:', config.theme, 'Compact:', config.compact);
                        }
                    })
                    .subscribe((status) => {
                        if (status === 'SUBSCRIBED') {
                            console.log('‚úÖ Listening for config updates on obs_config channel');
                        }
                    });

                obsChannel
                    .on('broadcast', { event: 'loadout_update' }, (payload) => {
                        console.log(`‚úÖ Received loadout from OBS channel`, payload);
                        // Add visible debug message for OBS
                        document.body.style.border = '3px solid lime';
                        setTimeout(() => { document.body.style.border = 'none'; }, 1000);
                        renderLoadout(payload.payload);
                    })
                    .subscribe((status, error) => {
                        if (error) {
                            console.error('‚ùå Channel subscription error:', error);
                            console.log('Channel error details:', error.message);
                        } else if (status === 'SUBSCRIBED') {
                            console.log(`‚úÖ Connected to OBS channel: obs_default! Waiting for loadouts...`);
                        } else if (status === 'CHANNEL_ERROR') {
                            console.error('‚ùå Channel error - check Supabase configuration');
                        } else if (status === 'TIMED_OUT') {
                            console.error('‚ùå Connection timed out - retrying...');
                        } else {
                            console.log(`Channel status: ${status}`);
                        }
                    });

                // Also listen on user's specific channel if provided
                if (supabaseChannelId && supabaseChannelId !== 'default') {
                    const userChannel = supabaseOverlay.channel(channelName);
                    userChannel
                        .on('broadcast', { event: 'loadout_update' }, (payload) => {
                            console.log(`‚úÖ Received loadout from user channel: ${channelName}`, payload);
                            renderLoadout(payload.payload);
                        })
                        .subscribe((status) => {
                            if (status === 'SUBSCRIBED') {
                                console.log(`‚úÖ Also connected to user channel: ${channelName}`);
                            }
                        });
                }
            } catch (e) {
                console.log('Supabase connection failed, falling back to localStorage/BroadcastChannel', e);
            }
        }
    </script>
</body>
</html>