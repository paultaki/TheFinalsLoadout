/**
 * Loadout History UI - Interactive Functions
 * Mobile-optimized vanilla JavaScript for the redesigned history interface
 */

class LoadoutHistoryUI {
  constructor() {
    this.historyContainer = document.getElementById('history-list');
    this.clearButton = document.getElementById('clear-history');
    this.totalCounter = document.getElementById('total-loadouts');
    
    this.init();
  }

  init() {
    this.setupEventListeners();
    this.observeHistoryChanges();
    this.setupIntersectionObserver();
  }

  /**
   * Set up event listeners for UI interactions
   */
  setupEventListeners() {
    // Clear history button
    if (this.clearButton) {
      this.clearButton.addEventListener('click', (e) => {
        e.preventDefault();
        this.handleClearHistory();
      });
    }

    // Delegate events for dynamically created elements
    if (this.historyContainer) {
      this.historyContainer.addEventListener('click', (e) => {
        this.handleHistoryAction(e);
      });
    }

    // Handle touch events for mobile
    this.setupTouchInteractions();
  }

  /**
   * Handle clicks on history actions (copy, analyze, etc.)
   */
  handleHistoryAction(e) {
    const button = e.target.closest('.action-btn');
    if (!button) return;

    e.preventDefault();
    e.stopPropagation();

    const entry = button.closest('.history-entry');
    if (!entry) return;

    // Add click feedback
    this.addClickFeedback(button);

    if (button.classList.contains('copy-btn')) {
      this.copyLoadout(entry);
    } else if (button.classList.contains('analyze-btn')) {
      this.analyzeLoadout(entry);
    }
  }

  /**
   * Copy loadout text to clipboard
   */
  async copyLoadout(entry) {
    try {
      const classType = entry.querySelector('.class-badge')?.textContent?.trim();
      const loadoutName = entry.querySelector('.loadout-name')?.textContent?.trim();
      const weapon = entry.querySelector('.weapon .item-name')?.textContent?.trim();
      const spec = entry.querySelector('.specialization .item-name')?.textContent?.trim();
      const gadgets = entry.querySelector('.gadgets .item-name')?.textContent?.trim();

      const loadoutText = `
🏆 ${loadoutName} (${classType})
🔫 Weapon: ${weapon}
⚡ Specialization: ${spec}
🛠️ Gadgets: ${gadgets}

Generated by thefinalsloadout.com
      `.trim();

      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(loadoutText);
        this.showToast('Loadout copied to clipboard!', 'success');
      } else {
        // Fallback for older browsers or non-secure contexts
        this.fallbackCopyText(loadoutText);
      }
    } catch (error) {
      console.error('Failed to copy loadout:', error);
      this.showToast('Failed to copy loadout', 'error');
    }
  }

  /**
   * Fallback copy method for older browsers
   */
  fallbackCopyText(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      document.execCommand('copy');
      this.showToast('Loadout copied to clipboard!', 'success');
    } catch (error) {
      this.showToast('Failed to copy loadout', 'error');
    }
    
    document.body.removeChild(textArea);
  }

  /**
   * Analyze loadout performance (placeholder for future functionality)
   */
  analyzeLoadout(entry) {
    const loadoutName = entry.querySelector('.loadout-name')?.textContent?.trim();
    
    // Toggle detailed view or show analysis modal
    this.toggleDetailedView(entry);
    
    // Could be expanded to show:
    // - Win rate statistics
    // - Meta analysis
    // - Similar loadout suggestions
    // - Performance trends
    
    this.showToast(`Analyzing ${loadoutName}...`, 'info');
  }

  /**
   * Toggle detailed view for a loadout entry
   */
  toggleDetailedView(entry) {
    const isExpanded = entry.classList.contains('expanded');
    
    // Close all other expanded entries
    document.querySelectorAll('.history-entry.expanded').forEach(e => {
      if (e !== entry) {
        e.classList.remove('expanded');
      }
    });

    // Toggle current entry
    entry.classList.toggle('expanded', !isExpanded);

    // Add detailed analytics view if expanded
    if (!isExpanded && !entry.querySelector('.detailed-analytics')) {
      this.addDetailedAnalytics(entry);
    }
  }

  /**
   * Add detailed analytics section to an entry
   */
  addDetailedAnalytics(entry) {
    const detailedSection = document.createElement('div');
    detailedSection.className = 'detailed-analytics';
    detailedSection.innerHTML = `
      <div class="analytics-header">
        <h4>Detailed Analysis</h4>
      </div>
      <div class="analytics-grid">
        <div class="analytics-item">
          <span class="analytics-label">Estimated TTK</span>
          <span class="analytics-value">0.8s</span>
        </div>
        <div class="analytics-item">
          <span class="analytics-label">Range Score</span>
          <span class="analytics-value">7.2/10</span>
        </div>
        <div class="analytics-item">
          <span class="analytics-label">Mobility</span>
          <span class="analytics-value">High</span>
        </div>
        <div class="analytics-item">
          <span class="analytics-label">Team Support</span>
          <span class="analytics-value">Medium</span>
        </div>
      </div>
      <div class="analytics-notes">
        <p>This loadout excels in close-quarters combat with high mobility. Consider using cover and vertical movement to maximize effectiveness.</p>
      </div>
    `;

    // Add styles for detailed analytics
    detailedSection.style.cssText = `
      margin-top: var(--space-md);
      padding: var(--space-md);
      background: var(--color-bg-primary);
      border-radius: var(--radius-md);
      border: 1px solid var(--color-divider);
      animation: slideDown 0.3s ease-out;
    `;

    entry.querySelector('.entry-content').appendChild(detailedSection);
  }

  /**
   * Handle clear history with confirmation
   */
  handleClearHistory() {
    if (window.confirm('Are you sure you want to clear all loadout history? This action cannot be undone.')) {
      // Clear the history (integrate with existing clear function)
      if (this.historyContainer) {
        // Animate out all entries
        const entries = this.historyContainer.querySelectorAll('.history-entry');
        entries.forEach((entry, index) => {
          setTimeout(() => {
            entry.style.animation = 'fadeOut 0.3s ease-out forwards';
          }, index * 50);
        });

        // Clear after animation
        setTimeout(() => {
          this.historyContainer.innerHTML = '';
          this.updateHistoryStats(0);
          this.showToast('History cleared successfully', 'success');
        }, entries.length * 50 + 300);
      }
    }
  }

  /**
   * Update history statistics
   */
  updateHistoryStats(count) {
    if (this.totalCounter) {
      // Animate the counter change
      this.animateCounter(this.totalCounter, parseInt(this.totalCounter.textContent) || 0, count);
    }
  }

  /**
   * Animate counter changes
   */
  animateCounter(element, startValue, endValue, duration = 1000) {
    const range = endValue - startValue;
    const increment = range / (duration / 16);
    let current = startValue;

    const timer = setInterval(() => {
      current += increment;
      if ((increment > 0 && current >= endValue) || (increment < 0 && current <= endValue)) {
        current = endValue;
        clearInterval(timer);
      }
      element.textContent = Math.floor(current).toLocaleString();
    }, 16);
  }

  /**
   * Set up touch interactions for mobile
   */
  setupTouchInteractions() {
    if (!('ontouchstart' in window)) return;

    // Add touch feedback to entries
    if (this.historyContainer) {
      this.historyContainer.addEventListener('touchstart', (e) => {
        const entry = e.target.closest('.history-entry');
        if (entry) {
          entry.classList.add('touching');
        }
      }, { passive: true });

      this.historyContainer.addEventListener('touchend', (e) => {
        const entry = e.target.closest('.history-entry');
        if (entry) {
          setTimeout(() => {
            entry.classList.remove('touching');
          }, 150);
        }
      }, { passive: true });
    }
  }

  /**
   * Set up intersection observer for entry animations
   */
  setupIntersectionObserver() {
    if (!window.IntersectionObserver) return;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    }, {
      threshold: 0.1,
      rootMargin: '50px'
    });

    // Observe existing entries
    document.querySelectorAll('.history-entry:not(.visible)').forEach(entry => {
      observer.observe(entry);
    });

    // Store observer for later use
    this.intersectionObserver = observer;
  }

  /**
   * Observe changes to history container for new entries
   */
  observeHistoryChanges() {
    if (!window.MutationObserver || !this.historyContainer) return;

    const observer = new MutationObserver((mutations) => {
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('history-entry')) {
            // Set up new entry
            node.classList.remove('visible');
            if (this.intersectionObserver) {
              this.intersectionObserver.observe(node);
            }
            
            // Stagger animation for multiple new entries
            const delay = Array.from(this.historyContainer.children).indexOf(node) * 100;
            setTimeout(() => {
              node.classList.add('visible');
            }, delay);
          }
        });
      });
    });

    observer.observe(this.historyContainer, {
      childList: true,
      subtree: true
    });
  }

  /**
   * Add visual feedback for button clicks
   */
  addClickFeedback(button) {
    button.style.transform = 'scale(0.95)';
    setTimeout(() => {
      button.style.transform = '';
    }, 150);

    // Add ripple effect
    const ripple = document.createElement('div');
    ripple.style.cssText = `
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.3);
      pointer-events: none;
      transform: scale(0);
      animation: ripple 0.6s linear;
      width: 20px;
      height: 20px;
      left: 50%;
      top: 50%;
      margin-left: -10px;
      margin-top: -10px;
    `;

    button.style.position = 'relative';
    button.style.overflow = 'hidden';
    button.appendChild(ripple);

    setTimeout(() => {
      ripple.remove();
    }, 600);
  }

  /**
   * Show toast notifications
   */
  showToast(message, type = 'info') {
    // Remove existing toasts
    document.querySelectorAll('.history-toast').forEach(toast => toast.remove());

    const toast = document.createElement('div');
    toast.className = `history-toast toast-${type}`;
    toast.textContent = message;

    const colors = {
      success: 'var(--color-success)',
      error: 'var(--color-error)',
      warning: 'var(--color-warning)',
      info: 'var(--color-light)'
    };

    toast.style.cssText = `
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: ${colors[type] || colors.info};
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      font-family: var(--font-family-primary);
      font-size: 14px;
      font-weight: 500;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      animation: toastSlideIn 0.3s ease-out;
      max-width: 90vw;
      text-align: center;
    `;

    document.body.appendChild(toast);

    // Auto remove after 3 seconds
    setTimeout(() => {
      toast.style.animation = 'toastSlideOut 0.3s ease-out forwards';
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  }

  /**
   * Generate performance stats for loadouts
   */
  generatePerformanceStats(weapon, specialization, gadgets, classType) {
    // This would integrate with your existing loadout analysis logic
    // For now, returning mock data that matches the design
    
    const chaosRating = Math.random() * 10;
    const metaScore = Math.random() * 10;
    const funFactor = Math.random() * 10;

    return {
      chaos: {
        value: chaosRating.toFixed(1),
        level: chaosRating < 3 ? 'low' : chaosRating < 6 ? 'medium' : chaosRating < 8 ? 'high' : 'extreme'
      },
      meta: {
        value: metaScore.toFixed(1),
        level: metaScore < 3 ? 'low' : metaScore < 6 ? 'medium' : metaScore < 8 ? 'high' : 'extreme'
      },
      fun: {
        value: funFactor.toFixed(1),
        level: funFactor < 3 ? 'low' : funFactor < 6 ? 'medium' : funFactor < 8 ? 'high' : 'extreme'
      }
    };
  }

  /**
   * Create a new history entry with the redesigned UI
   * This function would be called by your existing history logic
   */
  createHistoryEntry(loadoutData) {
    const {
      classType,
      weapon,
      specialization,
      gadgets,
      loadoutName,
      isSpicy = false,
      timestamp = 'Just now'
    } = loadoutData;

    const stats = this.generatePerformanceStats(weapon, specialization, gadgets, classType);
    
    const entry = document.createElement('div');
    entry.className = `history-entry${isSpicy ? ' spicy-loadout' : ''}`;
    entry.setAttribute('data-class', classType.toLowerCase());

    entry.innerHTML = `
      <div class="entry-indicator"></div>
      <div class="entry-content">
        <div class="entry-header">
          <div class="class-info">
            <span class="class-badge ${classType.toLowerCase()}">${classType.toUpperCase()}</span>
            <span class="loadout-name">${loadoutName}</span>
            ${isSpicy ? '<span class="spicy-badge">🌶️ SPICY</span>' : ''}
            <span class="rarity-dots">
              <span class="rarity-dot legendary" title="Legendary Weapon"></span>
              <span class="rarity-dot epic" title="Epic Specialization"></span>
              <span class="rarity-dot rare" title="Rare Gadgets"></span>
            </span>
          </div>
          <div class="entry-meta">
            <span class="timestamp">${timestamp}</span>
            <div class="entry-actions">
              <button class="action-btn copy-btn" title="Copy Loadout">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                  <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
              </button>
              <button class="action-btn analyze-btn" title="Analyze Performance">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                </svg>
              </button>
            </div>
          </div>
        </div>
        
        <div class="loadout-grid">
          <div class="loadout-item weapon">
            <span class="item-type">WPN</span>
            <span class="item-name">${weapon}</span>
          </div>
          <div class="loadout-item specialization">
            <span class="item-type">SPEC</span>
            <span class="item-name">${specialization}</span>
          </div>
          <div class="loadout-item gadgets">
            <span class="item-type">GADGETS</span>
            <span class="item-name">${gadgets.join(' • ')}</span>
          </div>
        </div>

        <div class="performance-stats">
          <div class="stat-group">
            <div class="stat">
              <span class="stat-label">Chaos Rating</span>
              <span class="stat-value chaos-${stats.chaos.level}">${stats.chaos.value}</span>
            </div>
            <div class="stat">
              <span class="stat-label">Meta Score</span>
              <span class="stat-value meta-${stats.meta.level}">${stats.meta.value}</span>
            </div>
            <div class="stat">
              <span class="stat-label">Fun Factor</span>
              <span class="stat-value fun-${stats.fun.level}">${stats.fun.value}</span>
            </div>
          </div>
        </div>
      </div>
    `;

    return entry;
  }
}

// Add required CSS animations
const style = document.createElement('style');
style.textContent = `
  @keyframes ripple {
    to {
      transform: scale(4);
      opacity: 0;
    }
  }

  @keyframes toastSlideIn {
    from {
      opacity: 0;
      transform: translate(-50%, -20px);
    }
    to {
      opacity: 1;
      transform: translate(-50%, 0);
    }
  }

  @keyframes toastSlideOut {
    from {
      opacity: 1;
      transform: translate(-50%, 0);
    }
    to {
      opacity: 0;
      transform: translate(-50%, -20px);
    }
  }

  @keyframes fadeOut {
    to {
      opacity: 0;
      transform: translateX(-100%);
    }
  }

  @keyframes slideDown {
    from {
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .history-entry.touching {
    background: var(--color-bg-card-hover) !important;
  }

  .history-entry.expanded {
    margin-bottom: var(--space-lg);
  }

  .detailed-analytics {
    animation: slideDown 0.3s ease-out;
  }

  .analytics-header h4 {
    margin: 0 0 var(--space-md) 0;
    font-size: var(--font-size-base);
    color: var(--color-text-accent);
  }

  .analytics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: var(--space-md);
    margin-bottom: var(--space-md);
  }

  .analytics-item {
    display: flex;
    flex-direction: column;
    gap: var(--space-xs);
  }

  .analytics-label {
    font-size: var(--font-size-xs);
    color: var(--color-text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .analytics-value {
    font-family: var(--font-family-mono);
    font-weight: var(--font-weight-bold);
    color: var(--color-text-primary);
  }

  .analytics-notes {
    padding: var(--space-md);
    background: var(--color-bg-secondary);
    border-radius: var(--radius-sm);
    border-left: 3px solid var(--color-light);
  }

  .analytics-notes p {
    margin: 0;
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary);
    line-height: 1.5;
  }

  @media (max-width: 480px) {
    .analytics-grid {
      grid-template-columns: 1fr;
      gap: var(--space-sm);
    }
  }
`;
document.head.appendChild(style);

// Initialize the LoadoutHistoryUI when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new LoadoutHistoryUI();
  });
} else {
  new LoadoutHistoryUI();
}

// Export for global access if needed
window.LoadoutHistoryUI = LoadoutHistoryUI;